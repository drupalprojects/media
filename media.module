<?php
// $Id$

/**
 *  @file
 *  A GUI for file management for upload forms.
 *  The Media module provides a drop-in replacement for Drupal's Upload,
 *  FileField, Embedded Media Field, and other similar forms. It offers an API
 *  and hooks available for other modules to implement, allowing for customized
 *  file lists, tabs, drawers, and forms to the new Upload form.
 */

/* ***************************************** */
/* DEFINITIONS                               */
/* ***************************************** */

define('MEDIA_RESOURCE_URI_DEFAULT', 'public://');
define('MEDIA_TYPES_DEFAULT', '*');

/* ***************************************** */
/* DRUPAL API FUNCTIONS                      */
/* ***************************************** */


/**
 * Implementation of hook_menu().
 *
 */
function media_menu() {
  // AJAX formatter
  $items['media/ahah'] = array(
    'page callback' => 'media_ahah_formatter_load',
    'access arguments' => array('access content'),
    'file' => 'media_ahah.inc',
  );

  // Media configuration parent path.
  $items['admin/content/media'] = array(
    'title' => 'Media',
    'description' => 'Configure your site\'s Media settings.',
    'page callback' => 'media_admin_settings',
    'access arguments' => array('administer media'),
    'file' => 'media_admin.inc',
  );
  
  // Default settings, for content types that do not have their own.
  $items['admin/content/media/global'] = array(
    'title' => 'Global and Default Media Settings',
    'description' => 'Configure Global Media settings, including default content type settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('media_admin_settings','global'),
    'access arguments' => array('administer media'),
    'file' => 'media_admin.inc',
    'weight' => 3,
  );
  
  // Top-level page for content types, split off because it gets crowded.
  $items['admin/content/media/types'] = array(
    'title' => 'Content Type Settings',
    'description' => 'Configure Media settings that are specific to a content type',
    'page callback' => 'media_admin_settings',
    'page arguments' => array('media_admin_settings','types'),
    'access arguments' => array('administer media'),
    'file' => 'media_admin.inc',
  );
  
  // Build pages for each content type.
  $content_types = node_get_types();
  if ($content_types) {
    foreach ($content_types as $content_type) {
      $items['admin/content/media/types/'. $content_type->type] = array(
        'title' => $content_type->name,
        'description' => 'Configure Media settings for '. $content_type->name,
        'page callback' => 'drupal_get_form',
        'page arguments' => array('media_admin_settings', $content_type->type),
        'access arguments' => array('administer media'),
        'file' => 'media_admin.inc',
        'type' => MENU_CALLBACK,
      );
    }
  }
  
  return $items;
}

/**
 * Implementation of hook_form_alter().
 * @param $form
 * @param $form_state
 * @param $form_id
 *
 */
function media_form_alter(&$form, $form_state, $form_id) {
  global $user;

  // Add the media browser on the node add/edit screen.
  if (strstr($form_id, 'node_form') ) {
    // Is the media browser enabled on this node type? Type-specific options override the default.
    if (variable_get('media_'. $form['type']['#value'] .'_override', null)) {
      $enabled = variable_get('media_'. $form['type']['#value'] .'_enabled', NULL);
    }
    else {
      $enabled = variable_get('media_global_enabled', 1);
    }
    if ($enabled) {
      // Get the fields we need to enable on this module.
      $fields = media_active_fields_for_node_type($form['type']['#value']);
      foreach ($fields as $field => $registration_ids) {
        $form[$field]['media'] = media_build_browser_form($registration_ids, $form['type']['#value'], $field, $user->uid);
        $form[$field][0]['#attributes'] = array('class' => 'media replace');
      }
    }
  }
}


/**
 * Implements hook_theme().
 * Register theming functions
 * @return array
 */
function media_theme() {
  return array(
    'media_file_browser' => array(
      'file' => 'media_theme.inc',
      'arguments' => array('element' => NULL),
    ),
    'media_file_list' => array(
      'file' => 'media_theme.inc',
      'arguments' => array('element' => NULL),
    ),
    'media_browser_pane' => array(
      'file' => 'media_theme.inc',
      'arguments' => array('form' => array()),
    ),
  );
}


/* ***************************************** */
/* Media hook calls                          */
/* ***************************************** */

/**
 * Gets all of the modules which register with Media.
 * @param array $ids
 *   (Optional) If this contains an array of id strings, then return only the
 *   specified ids.
 * @param boolean $reset
 *   (Optional) If TRUE, then reset the static cache.
 * @return array
 *   An array of registrations, keyed by implementing function name, in the
 *   form of:
 *     'module' => The module implementing the hook.
 *     'uri' => The scheme the stream wrapper handles, default is 'public://'.
 *     'types' => The mime types this module handles, defaults to * (all).
 *     'name' => A human readable name, displayed on forms.
 *     'kind' => Kind of functionality: 'resource' or 'format'.
 *     'description' => A verbose description of functionality.
 *     'callbacks' => An array of key => functions called for data.
 *     'fields' => What fields does this functionality operate on?
 *     'validation' => @todo
 *     'display' => @todo
 */
function media_get_registered_modules($ids = NULL, $reset = FALSE) {
  static $registrations;
  // Only build cache the first time the function is called, or if we reset it.
  if (is_null($registrations) || $reset) {
    $registrations = array();
    // Get all the modules which implement media_register().
    foreach (module_implements('media_register') as $module) {
      $function = $module .'_media_register';
      // Get all the registrations.
      $registration = $function();
      // Add the module name to each registration.
      foreach (array_keys($function()) as $key) {
        $registration[$key]['module'] = $module;
        if (!$registraton[$key]['uri']) {
          $registration[$key]['uri'] = MEDIA_RESOURCE_URI_DEFAULT;
        }
        if (!$registration[$key]['types']) {
          $registration[$key]['types'] = MEDIA_TYPES_DEFAULT;
        }
      }
      $registrations = array_merge($registrations, $registration);
    }
  }
  // Return requested registrations.
  if ($ids) {
    foreach ($ids as $id) {
      $return[$id] = $registrations[$id];
    }
    return $return;
  }
  return $registrations;
}


/* ***************************************** */
/* Media API Functions                       */
/* ***************************************** */

/**
 * Build a list of possible registration types.
 *
 * @return array
 */
function media_registration_kinds() {
  return array('resource', 'formatter');
}



/**
 * Get all fields that can be enabled on a field type.
 * @param string $type
 *   The field type to get items for.
 * @param string $function_type
 *   The kind of functionality being looked for.
 * @return array
 *   Array of full registration objects.
 */
function media_get_fields($field_type, $function_type = 'resource') {
  static $data;

  // Do we have cached version?
  if ($data[$field_type][$function_type]) {
    return $data[$field_type][$function_type];
  }

  $data = array();
  // Get all the registered modules.
  foreach (media_get_registered_modules() as $id => $registration) {
    // Check to see if this registration supports this function type.
    if ($registration['kind'] == $function_type) {
      // Now look for the fields.
      if ($registration['fields']) {
        foreach ($registration['fields'] as $field) {
          // If this registration supports this field type, add it to the
          // returned array.
          if ($field == $field_type) {
            $data[$field_type][$function_type][$id] = $registration;
          }
        }
      }
    }
  }
  return $data[$field_type][$function_type];
}


/**
 * Select registrations for use by matching against uri and file extension.
 *
 * @param array $registrations
 *   Array of extensions.
 * @param string $uri
 *   The kind of uri being used.
 * @param string $file_extension
 *   The current file extension.
 * @return array
 *   An array of applicable formatters.
 */
function media_get_applicable_formatters($registrations, $file_extension) {
  // Do we have a file extension?
  if ($file_extension) {
    foreach ($registrations as $id => $formatter) {
      // Does this formatter use any file type? If not, then we have to dig.
      if (!$formatter['types'] == MEDIA_TYPES_DEFAULT) {
        // We need to see if this file type is supported specifically.
        if (!in_array($file_extension, $registration['types'])) {
          // This registration is not useful.
          unset($registrations[$id]);
        }
      }
    }
  }
  return $registrations;
}


/* ***************************************** */
/* Media Internal Functions                  */
/* ***************************************** */

/**
 * Parsing function for the registrations to hand back the kinds of modules
 * registering. Used to select all formatters, resources, etc.
 * @param string $kinds
 *   Return all the matching registrations of this kind.
 * @return array
 *   An array of matching registrations.
 */
function media_get_registration_kinds($kind = NULL) {
  $kinds = array();
  // Get the registered modules.
  $registrations = media_get_registered_modules();
  // Parse the registrations.
  foreach ($registrations as $id => $registration) {
    if ($kind) {
      // Get the kind that is being looked for.
      if ($registration['kind'][$kind]) {
        $kinds[$id] = $registration;
      }
    }
    else {
       $kinds[$id] = $registration;
    }
  }
  return $kinds;
}


/**
 * Returns a set of formatters which can format the specified item. If
 * $description is NULL, all formatters will be returned. If a set of
 * registered modules can be passed in to narrow the formatter options.
 * @param string $description
 *   File extension to return.
 * @param array $registrations
 *   (Optional) If specified, then match only against these registrations.
 * @return array
 *   An array of formatter ids keyed by module.
 */
function media_registration_item_formatters($description = '*', $registrations = NULL) {
  $formatters = array();
  // Get all the registrations if we don't have any.
  if (is_null($registrations)) {
    $registrations = media_get_registered_modules();
  }
  // Iterate through each of the registered modules and find the formatters.
  foreach ($registrations as  $id => $registration) {
    // look for the formatter, or just take all
    if ((is_array($registration['kind']['formatter']['types']) && in_array($registration['kind']['formatter']['types'], $description))
      || $description == '*'
      || $registration['kind']['formatter']['types'] == '*') {
      $formatters[$registration['module']] = $id;
    }
  }
  return $formatters;
}


/**
 * Parsing function for the registrations to hand back the kinds of modules
 * registering.
 * @param string $type
 *   Only hand back data for the specified type.
 * @return array
 * @TODO: finish this function.
 */
function media_registration_types($type = NULL) {
  // get the registered modules
  $registrations = media_get_registered_modules();
  // parse the registrations
  foreach ($registrations as $registration) {
    // @TODO
  }
}



/**
 * Parsing function for the registrations to hand back the kinds of modules
 * registering.
 * @param string $array
 *   Name of the element we want to get data from.
 * @return array
 */
function media_registration_data($name) {
  $data = array();
  // Get the registered modules.
  $registrations = media_get_registered_modules();
  // Parse the registrations.
  foreach ($registrations as $id => $registration) {
    // Do we have this data in this registration?
    if ($registration[$name]) {
      // Get the item that was requested.
      $data[$registration['module']] = array(
        $id => array(
          $name => $registration[$name],
          'description' => $registration['description']
        )
      );
    }
  }
  return $data;
}


/**
 * Fetches all resources registered in $resources.
 * @TODO Implement admin weighting here somehow.
 * @param array $registration_ids
 *   Array of registration ids to be loaded.
 * @param string $node_type
 *   Drupal node type.
 * @param field $field
 *   CCK field name.
 * @param int $uid
 *   Drupal {user} id.
 * @return array
 */
function media_get_resources($registration_ids, $node_type, $field, $uid) {
  // Get all the registrations that define the resources.
  $registrations = media_get_registered_modules($registration_ids);
  foreach ($registrations as $id => $registration) {
    // Get the callback function.
    $function = $registration['callbacks']['resource'];
    if (function_exists($function)) {
      // Get the results of the callback function.
      $item = $function($node_type, $field, $uid);
      $tab_name = key($item);
      // Add a resource_id to the item.
      $item[$tab_name][key($item[$tab_name])]['resource_id'] = array(
        '#type' => 'value',
        '#value' => $id,
      );
      // Add tabs under the tab name.
      $items[$tab_name][key($item[$tab_name])] = $item[$tab_name][key($item[$tab_name])];
    }
  }
  return $items;
}


/**
 * Get a list of fields for the requested node type.
 *
 * @param string $type_name
 *   Drupal {node} type.
 * @param string $function
 *   Either 'resource' or 'formatter'.
 * @return array
 *   An array of field names.
 */
function media_active_fields_for_node_type($type_name, $function = 'resource') {
  //@TODO: Some of this code is redundant with media_admin_settings
  if (module_exists('content')) {
    $type = content_types($type_name);
  }
  else {
    // Get the specific content type.
    $type = (array) node_get_types('type', $type_name);
  }
  // Add the upload form as a type of faux field.
  if (is_array($type['extra']['attachments'])) {
    $type['fields']['attachments'] = array(
      'field_name' => 'attachments',
      'type' => 'attachments',
      'widget' => array(
        'label' => $type['extra']['attachments']['label'],
      ),
    );
  }
  
  // Need to know if the type-specific or global settings are going to be used.
  // At least one of them is enabled at this point.
  $type_override = variable_get('media_'. $type_name .'_override', false);

  $items = array();
  // extract the fields for this node type
  foreach ((array)$type['fields'] as $field_name => $field) {
    // Ignore the content-type specific per-field setting unless the override is set
    $fields_enabled = false;
    if ($type_override) {
      $fields_enabled = variable_get('media_'. $type_name .'_'. $field['field_name'] .'_'. $function,false);
    }
    else {
      //@TODO: Right now, if it's using the default it will be enabled for all fields.
      // Eventually it will probably be better to allow per-field controls at a global level as well.
      // However, this line will probably just work once the actual variables exist.
      $fields_enabled = variable_get('media_global_'. $field['field_name'] .'_'. $function,'default');
      // Handle the default special, because we want the default to be on for all fields but don't know what the fields are yet.
      if ($fields_enabled === 'default') {
        $fields_enabled = array();
        foreach (media_registration_kinds() as $kind) {
          // get all the kinds that match this field
          if ($registrations = media_get_fields($field['type'], $kind)) {
            foreach ($registrations as $id => $registration) {
              $compound_id = $field['field_name'] .'--'. $id;
              $fields_enabled[$compound_id] = $compound_id;
            }
          }
        }
      }
    }
    if (!empty($fields_enabled)) {
      $items[] = $fields_enabled;
    }
  }

  $data = array();
  foreach ($items as $item) {
    foreach ($item as $id => $value) {
      // we need to split the $id into $field_name and $media registration id
      if ($value) {
        $id = explode('--', $id);
        $data[$id[0]][] = $id[1];
      }
    }
  }
  return $data;
}


/**
 * Sanitize the incoming name to be used for a html #id.
 *
 * @param string $drawer_name
 * @return string
 */
function media_create_id($drawer_name) {
  return str_replace(array(' ', "'", '"', "%", "<", ">"), '', $drawer_name);
}

/* *************************************************** */
/* Media forms                                         */
/* *************************************************** */

/**
 * Build data for the media browser display.
 * @TODO Clean this form up and use a form theme function.
 * @param array $registration_ids
 *   Array of registrations to call.
 * @param string $node_type
 * @param string $field
 * @param uid $uid
 * @return array
 *   Drupal FAPI form array.
 */
function media_build_browser_form($registration_ids, $node_type, $field, $uid) {
  // Load our css.
  drupal_add_css(drupal_get_path('module', 'media') .'/media.css');
  // Load our specific js for the file selector
  drupal_add_js(drupal_get_path('module', 'media') .'/javascript/media.js');
  // load the md5 library so we can hash the upload filename for use in the meta form
  drupal_add_js(drupal_get_path('module', 'media') .'/javascript/jquery.md5.js');
  
  $items = array();
  $form = array();

  $form['media_browser_activate'] = array(
    '#type' => 'markup',
    '#value' => '<div class="media browser activation">'. t('Add files') .'</div>',
  );
  
  // we are using a tab form type
  $form['media_browser'] = array(
    '#type' => 'tabset',
    '#attributes' => array('class' => 'media browser wrapper'),
  );
  
  // Get all the active resources 
  $resources = media_get_resources($registration_ids, $node_type, $field, $uid);

  // loop through the form and start pulling out the data to
  // create tabs -> panes -> drawers 
  foreach($resources as $tab_name => $data) {
    // create a tab id
    $tab_id = strtolower(str_replace(' ', '_', $tab_name));
    // create tab 
    $form['media_browser'][$tab_id] = array(
      '#type' => 'tabpage',
      '#title' => $tab_name,
      '#theme' => 'media_browser_pane',
    );
    
    // build the drawers for this tab
    $drawer_list = array();
    $active_drawer = true;
    // check to see if we do have children- we should, but just in case
    if (is_array($data)) {
      $drawers = array();
      foreach ($data as $drawer_name => $drawer_data) {
        // @TODO check drawer access permissions here to make 
        //       sure we should present this to the user
        
        // the drawer id needs to have additional data on it to prevent
        // name space conflicts with ids
        $drawer_id = strtolower(str_replace(' ', '_', $drawer_name)) .'_display';
        // create a link with a specific id to call
        $drawers_link = '<a onclick="javascript: return false;" href="#'. $drawer_id .'">'. $drawer_name .'</a>';
        $drawer_list[] = array('data' => $drawers_link, 'class' =>  ($active_drawer ? 'active' : '') ); 
        // add the drawer form element        
        $form['media_browser'][$tab_id][$drawer_name] = $drawer_data;
        // add classes to the drawer display item
        $form['media_browser'][$tab_id][$drawer_name]['#prefix'] = '<div id="'. $drawer_id .'" class="drawer display ' . ($active_drawer ? ' active' : null) .'">';
        $form['media_browser'][$tab_id][$drawer_name]['#suffix'] = '</div>';
        
        // no longer on the first drawer
        $active_drawer = false;
      }
      // change the drawers to a list for easer display
      $form['media_browser'][$tab_id]['drawers'] = array(
        '#type' => 'markup',
        '#value' => theme('item_list', $drawer_list, null, 'ul', array('class' => 'drawers'))
      );
    }
  }
  
  // build the tabs into a single form element
  // @TODO make sure we have children for each tab and remove any that
  //       we don't have data for
  $form['tabs'] = array(
    '#type' => 'markup',
    '#value' => theme('item_list', $tabs, null, 'ul', array('class' => 'tabs')),
  );
  
  return $form;
}

/**
 * Display files in a form element. Default for other modules to make use of.
 * @param array $files
 *   array of (uri => uri, filename => filename, meta => array(key => value))
 * @param string $title
 *   option title argument
 * @return string
 */
function media_resource_display_user_files_form($files, $title = NULL) {
  // Pass files into options array.
  $options = array();
  foreach ($files as $file) {
    $options[$file['uri']] = $file['filename'];
  }
  // Parse files into form element.
  $form['media_files'] = array(
    '#type' => 'select',
    '#options' => $options,
    '#title' => $title ? $title : '',
    '#attributes' => array('class' => 'resource select'),
    '#size' => variable_get('media_file_list_size', 10),
  );
  return $form;
}


/**
 * Display the upload form for the tab.
 * @return string
 */
function media_resource_display_upload_form() {
  $form['media_upload']['upload'] = array(
    '#type' => 'file',
    '#title' => t('Upload your file'),
    '#size' => 30,
    '#attributes' => array('class' => 'resource select'),
   );
   return $form;
}


/* ***************************************** */
/* Media Hook Implementations                */
/* ***************************************** */


/**
 * Implementation of hook_media_register().
 * @return array
 *
 */
function media_media_register() {
  $registration = array(
    'media_user_files' => array(
      // Human readable name.
      'name' => t('User files'),
      'uri' => 'file',
      'kind' => 'resource',
      'types' => '*',
      'description' => t('Format Drupal uploaded files.'),
      'callbacks' => array(
        'resource' => 'media_display_user_files',
       ),
       // Human readable description.
      'description' => t('Displays all of current user\'s files.'),
      'fields' => array('attachments', 'filefield'),
    )
  );
  return $registration;
}


/**
 * Implementation of hook_media_user_files_select().
 * @TODO move this to a specific module rather than the core module
 * @param string $node_type
 * @param string $field
 * @param int $uid
 */
function media_display_user_files($node_type, $field, $uid) {
  $files = array();
  $results = db_query('SELECT filepath, filename FROM {files} WHERE uid = %d', $uid);
  while ($file = db_fetch_array($results)) {
    $files[] = array(
      'uri' => $file['filepath'],
      'filename' => $file['filename'],
      'meta' => '',
    );
  }
  $return = array(
    t('My files') => array(
      t('Local') => media_resource_display_user_files_form($files, t('Your files')),
    )
  );
  return $return;
}

/**
 *  Implementation of hook_elements().
 *  A Media File List element is created with the following FAPI:
 *    '#type' => 'media_file_list',
 *    '#options' => $options,         // An associative array of filepaths, keyed by FID.
 *    '#title' => $title,             // The translated title, displayed in the tab.
 *    '#description' => $description, // A translated description, to be displayed below the title.
 */
function media_elements() {
  $elements = array();
  $elements['media_file_list'] = array(
    '#input' => TRUE,
    '#process' => array('media_file_list_element_process'),
    '#element_validate' => array('media_file_list_element_validate'),
    '#submit' => array('media_file_list_element_submit'),
  );
  return $elements;
}

/**
 *  Process callback for the media_browser element.
 * @param $element
 * @param $edit
 * @param $form_state
 * @param $form
 * @return
 *   array
 */
function media_file_list_element_process($element, $edit, $form_state, $form) {
  $element['list'] = array(
    '#type' => 'select',
    '#options' => $element['#options'],
    '#size' => variable_get('media_file_list_size', 10),
  );
  return $element;
}

/**
 * Submit callback for the media_browser element.
 */
function media_file_list_element_submit($form, $form_state) {
  drupal_set_message('Successful submit of the Media File List...');
}

/**
 * Validate callback for media_browser element.
 */
function media_file_list_element_validate($element, $form_state) {
  drupal_set_message('Successful validation of the Media File List...');
  return $element;
}

